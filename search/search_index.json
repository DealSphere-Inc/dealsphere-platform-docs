{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DealSphere Platform Documentation","text":"<p>Welcome to the official docs for the DealSphere platform. This documentation is the single source of truth for all architecture decisions, technical implementation details, product requirements, QA/test coverage, and delivery planning.</p>"},{"location":"#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":"<ul> <li> <p>Architecture Decision Records (ADRs)</p> <ul> <li>Trace all critical technology and architecture decisions.</li> <li>Find each ADR and the ADR Master Index for rationale/history.</li> </ul> </li> <li> <p>Planning</p> <ul> <li>Contains weekly epics table (phase1-epics.md), delivery plans, phase breakdowns, and milestone maps.</li> </ul> </li> <li> <p>Product</p> <ul> <li>Contains Product Requirements Documents (PRDs) and feature specs, versioned per release.</li> </ul> </li> <li> <p>QA &amp; Compliance</p> <ul> <li>End-to-end acceptance criteria, functional test cases, traceability matrix, and compliance documentation.</li> </ul> </li> <li> <p>Technical Documentation</p> <ul> <li>Implementation plans, technology landscape overviews, demo/release guides, and the release process.</li> </ul> </li> </ul>"},{"location":"#quick-navigation","title":"\ud83d\udd17 Quick Navigation","text":"<ul> <li>ADR Master Index</li> <li>Phase 1 Epics and Delivery Plan</li> <li>Phase 1 Product Requirements (PRD)</li> <li>Functional Test Cases</li> <li>Tech Landscape (MVP)</li> <li>Release Process</li> <li>Phase 1 Technical Plan</li> </ul> <p>See each subdirectory for additional documentation, internal guides, and implementation notes. When in doubt, start with the README in that folder.</p>"},{"location":"#contributing","title":"\ud83d\udea6 Contributing","text":"<ul> <li>Propose process/architecture changes by adding an ADR or PR and cross-linking related documentation.</li> <li>Follow ADR-0000-template for major decisions, and respect doc/file naming conventions.</li> <li>Keep language concise and always map changes to existing PRD, planning, and QA docs.</li> </ul>"},{"location":"#getting-help","title":"\ud83d\udca1 Getting Help","text":"<ul> <li>If unsure, review ADRs and planning/technical docs for context.</li> <li>For process/feature/test traceability, follow the links above or contact the core platform team listed internally.</li> </ul> <p>Last updated: August 2025 \u2013 All core tech, planning, and QA documentation is actively maintained during MVP delivery.</p>"},{"location":"adr/","title":"Architecture Decision Records (ADRs)","text":"<p>This directory contains Architecture Decision Records for the DealSphere platform. ADRs document important architectural decisions made during platform development. Each ADR should be updated in this index with its number, title, status, tags, and date.</p>"},{"location":"adr/#adr-index","title":"ADR Index","text":"ADR Title Status Tags Date ADR-0001 Java 17 Runtime Accepted runtime, java, backend 2025-XX-XX ADR-0002 R3 Corda 5 DLT Platform Accepted blockchain, dlt, backend 2025-XX-XX ADR-0003 Docker Compose Phase 1 Orchestration Accepted deployment, orchestration 2025-XX-XX ADR-0004 Service Framework Defaults Accepted architecture, tech-stack 2025-XX-XX ADR-000-template ADR Authoring Template - meta, template 2025-XX-XX <p>Replace XX-XX in Date with actual decision dates.</p>"},{"location":"adr/#status-definitions","title":"Status Definitions","text":"<ul> <li>Accepted: Decision finalized and in production use.</li> <li>Open: Still under discussion/trial; current choice and alternatives listed.</li> <li>Deprecated: No longer applies (historical only).</li> <li>Superseded: Explicitly replaced by a newer ADR.</li> </ul>"},{"location":"adr/#adr-process","title":"ADR Process","text":"<p>To create a new ADR: 1. Copy <code>ADR-000-template.md</code> to a new file with next sequential number and short title, e.g. <code>ADR-0005-storage-choice.md</code> 2. Fill all required sections using bolded headings. 3. Reference related ADRs by number and brief title (e.g. <code>[0001](ADR-0001-java-17-runtime.md) Java 17</code>) 4. Update this index table with the new ADR. 5. Submit a pull request for review by the core team.</p> <p>General Guidelines - Chronological numbering (ADR-XXXX). - Use descriptive tags (architecture, api, security, performance, etc). - For \"Open\" ADRs, document deferred alternatives and triggers for revisit. - Keep this README as the authoritative ADR directory for the repo.</p>"},{"location":"adr/#common-tags","title":"Common Tags","text":"<ul> <li><code>architecture</code> \u2013 Platform/system architecture patterns</li> <li><code>database</code> \u2013 Persistence and storage</li> <li><code>api</code> \u2013 API design/standards</li> <li><code>security</code> \u2013 Auth, privacy, encryption</li> <li><code>performance</code> \u2013 Optimization, scalability</li> <li><code>monitoring</code> \u2013 Logging, metrics, alerting</li> <li><code>deployment</code> \u2013 CI/CD, infra, containerization</li> <li><code>integration</code> \u2013 External/partner interfaces</li> </ul> <p>Last updated: August 2025 \u2013 update table and tags as new decisions are finalized.</p>"},{"location":"adr/ADR-0000-template/","title":"ADR-XXXX: [title]","text":"<p>Author: @author Status: [Draft | Proposed | Accepted | Rejected | Deprecated | Superseded by ADR-XXXX] Date: YYYY-MM-DD Deciders: @name1, @name2, @name3 Technical Story: [optional link to ticket/issue] Tags: [tag1, tag2, tag3]</p>"},{"location":"adr/ADR-0000-template/#context","title":"Context","text":"<ul> <li>[Description of the problem space and why a decision needs to be made]</li> <li>[What is the issue that we're seeing that is motivating this decision or change?]</li> </ul>"},{"location":"adr/ADR-0000-template/#decision","title":"Decision","text":"<p>[Description of the solution/approach being chosen or What is the change that we're proposing and/or doing?]</p> <p>For now: - [Placeholder for current implementation approach] - [Placeholder for immediate next steps] - [Placeholder for temporary measures]</p>"},{"location":"adr/ADR-0000-template/#rationale","title":"Rationale","text":"<p>[Why is this the right decision given our architectural pillars?]</p>"},{"location":"adr/ADR-0000-template/#rationale-pillars","title":"Rationale Pillars","text":""},{"location":"adr/ADR-0000-template/#why-title-status","title":"Why [title] ([status])","text":"<ul> <li>Pillar 1 (e.g., Stability and Support)</li> <li>Supporting detail 1</li> <li> <p>Supporting detail 2</p> </li> <li> <p>Pillar 2 (e.g., Ecosystem Readiness)</p> </li> <li>Supporting detail 1</li> <li> <p>Supporting detail 2</p> </li> <li> <p>Pillar 3 (e.g., Team Proficiency and Velocity)</p> </li> <li>Supporting detail 1</li> <li> <p>Supporting detail 2</p> </li> <li> <p>Pillar 4 (e.g., Modern Features without migration burden)</p> </li> <li>Supporting detail 1</li> <li> <p>Supporting detail 2</p> </li> <li> <p>Pillar 5 (e.g., Risk Management)</p> </li> <li>Supporting detail 1</li> <li> <p>Supporting detail 2</p> </li> <li> <p>Pillar 6 (e.g., Upgrade Path Considerations)</p> </li> <li>Supporting detail 1</li> <li>Supporting detail 2</li> </ul>"},{"location":"adr/ADR-0000-template/#deferred-alternatives","title":"Deferred Alternatives","text":"<p>[What alternatives are we deferring for future consideration?]</p> <p>Alternative: [Name] - Trigger: [What condition would make us reconsider this?] - Timeline: [When should we revisit this?] - Reason for deferral: [Why not now?]</p> <p>Alternative: [Name] - Trigger: [What condition would make us reconsider this?] - Timeline: [When should we revisit this?] - Reason for deferral: [Why not now?]</p>"},{"location":"adr/ADR-0000-template/#rejected-alternatives","title":"Rejected Alternatives","text":"<p>[What alternatives are we rejecting?]</p> <ul> <li>Alternative X: Brief description and reason for rejection</li> <li>Alternative Y: Brief description and reason for rejection</li> </ul>"},{"location":"adr/ADR-0000-template/#consequences","title":"Consequences","text":"<p>[What becomes easier or more difficult to do because of this change?]</p> <p>Positive: - Benefit 1 - Benefit 2 - ...</p> <p>Negative: - Risk 1 - Risk 2 - ...</p> <p>Mitigation Strategies: - ... - ...</p>"},{"location":"adr/ADR-0000-template/#revisit-triggers","title":"Revisit Triggers","text":"<ul> <li>Condition 1 (e.g., ecosystem certification, measurable benefit)</li> <li>Condition 2 (e.g., scheduled upgrade window with regression capacity)</li> </ul>"},{"location":"adr/ADR-0000-template/#target-sprint-for-formal-decision","title":"Target Sprint for Formal Decision","text":"<ul> <li>Target Sprint: Sprint N (or timeframe) for adoption/change</li> </ul>"},{"location":"adr/ADR-0000-template/#guardrails","title":"Guardrails","text":""},{"location":"adr/ADR-0000-template/#must","title":"Must","text":"<ul> <li>Critical requirements that cannot be compromised</li> <li>Non-negotiable constraints</li> </ul>"},{"location":"adr/ADR-0000-template/#should","title":"Should","text":"<ul> <li>Important considerations that should be followed unless there's strong justification</li> <li>Best practices and preferred approaches</li> </ul>"},{"location":"adr/ADR-0000-template/#wont","title":"Won't","text":"<ul> <li>Explicit exclusions and out-of-scope items</li> <li>Things we deliberately choose not to do</li> </ul>"},{"location":"adr/ADR-0000-template/#approvals","title":"Approvals","text":"Review Reviewer Date (YYYY-MM-DD) Status Notes Architectural Review Pending Security Review Pending SRE Review Pending"},{"location":"adr/ADR-0000-template/#links","title":"Links","text":"<p>Review Before Deciding: - Performance benchmarks: /docs/benchmarks/api-performance.md - Security guidelines: /docs/security/security-guidelines.md - Architecture principles: /docs/architecture/principles.md - Technology radar: /docs/tech-radar/technology-radar.md - Cost analysis framework: /docs/cost-analysis/framework.md - Scalability patterns: /docs/patterns/scalability-patterns.md - Monitoring standards: /docs/monitoring/standards.md - Compliance requirements: /docs/compliance/requirements.md  </p> <p>Technology Landscape: [Link to relevant technology documentation]  </p> <p>Product/PRD: [Link to product requirements document]  </p> <p>Sprint Plan:[Link to sprint planning documentation]  </p> <p>Related ADRs: - [Link to related ADR] - [Link to related ADR]  </p>"},{"location":"adr/ADR-0001-java-17-runtime/","title":"ADR-0001: Java 17 as Language/Runtime","text":"<p>Author: @MysterTech Status: Accepted Date: 2025-08-13 Deciders: @MysterTech Technical Story: [optional link to ticket/issue] Tags: contracts, protobuf, versioning</p>"},{"location":"adr/ADR-0001-java-17-runtime/#context","title":"Context","text":"<ul> <li>We need a stable, well-supported runtime to deliver Phase 1 reliably; mixed Java versions and ad-hoc JDK choices across services are causing build inconsistencies, flaky CI pipelines, and environment drift between local/dev/prod.</li> <li>Several core frameworks (e.g., Spring Boot 3.x) and observability/tooling baselines are officially validated on Java 17; targeting newer LTS versions prematurely risks dependency incompatibilities and unplanned refactors during critical delivery windows.</li> <li>Teams are losing time troubleshooting version-specific quirks (toolchain, plugins, container images) due to lack of a single runtime standard, slowing onboarding and cross-service collaboration.</li> <li>Security updates and support timelines are harder to manage with heterogeneous runtimes; we need predictable LTS maintenance to meet operational and compliance expectations.</li> <li>Phase 1 emphasizes reliability and maintainability over adopting the newest features, so a proven LTS (Java 17) minimizes delivery risk while keeping a clear path for future upgrades.</li> </ul>"},{"location":"adr/ADR-0001-java-17-runtime/#decision","title":"Decision","text":"<p>Adopt Java 17 as the standard language/runtime for all backend services in Phase 1.</p>"},{"location":"adr/ADR-0001-java-17-runtime/#rationale","title":"Rationale","text":""},{"location":"adr/ADR-0001-java-17-runtime/#why-java-17-accepted","title":"Why Java 17 (Accepted)","text":"<p>Stability and Support (LTS) - Predictable maintenance and security updates aligned with enterprise expectations. - Reduced risk window during Phase 1 due to longer support horizon. - Vendor ecosystem (JDK vendors, container images) provides mature, stable distributions.</p> <p>Ecosystem Readiness - Frameworks   - Spring Boot 3.x and related starters are widely validated on Java 17.   - Strong ecosystem of testing libraries (JUnit 5, Testcontainers) supports Java 17. - Tooling   - Build tools (Gradle/Maven) natively support Java 17 toolchains.   - Observability agents (e.g., OpenTelemetry Java agent) and profilers are Java 17\u2013compatible. - CI/CD   - Cloud runners and base images for Java 17 are standard and maintained.</p> <p>Team Proficiency and Velocity - Familiarity with JVM reduces onboarding and avoids context switching. - Established patterns for debugging, profiling, and tuning on the JVM. - Minimizes polyglot operational overhead in Phase 1.</p> <p>Modern JVM Features (without near-term migration burden) - Language features   - Records for concise immutable data carriers.   - Sealed classes for controlled inheritance and domain modeling. - Runtime improvements   - Mature GC options (e.g., G1/ZGC) for latency-sensitive services.   - JVM performance optimizations benefiting microservices footprints.</p> <p>Risk Management for Phase 1 - Avoids introducing a new LTS upgrade path mid\u2011phase (e.g., Java 21) before dependency readiness. - Minimizes integration churn across multiple services and pipelines. - Keeps focus on delivering PRD-defined core flows rather than platform migrations.</p> <p>Upgrade Path Considerations - Structured path to Java 21 (or newer) when:   - Critical dependencies are certified and performance gains are tangible.   - A test window is scheduled to run regression/performance suites. - Build toolchain configured to ease future LTS bumps (centralized toolchain configuration).</p>"},{"location":"adr/ADR-0001-java-17-runtime/#alternatives-considered","title":"Alternatives Considered","text":"<p>Java 21 LTS - Pros: Newer LTS with incremental JVM improvements. - Cons: Some dependencies/tooling may lag certification; introducing an upgrade during Phase 1 could add risk and testing overhead.</p> <p>Kotlin-first on JVM - Pros: Language ergonomics (null-safety, coroutines, data classes). - Cons: Baseline language shift not required to meet PRD Phase 1 goals; can be introduced selectively later without changing runtime.</p> <p>Node/TypeScript - Pros: Rapid iteration for certain I/O-heavy services. - Cons: Polyglot complexity, diverges from JVM stack and team strengths; not necessary to meet Phase 1 scope.</p>"},{"location":"adr/ADR-0001-java-17-runtime/#consequences","title":"Consequences","text":"<p>Positive: - Consistent build and runtime across services, simplifying CI/CD pipelines and operational practices. - Access to modern JVM features (e.g., records, sealed classes, improved GC), improving code clarity and potential performance. - Strong ecosystem support accelerates development and minimizes integration risks. - Team proficiency with JVM enables faster onboarding and debugging capabilities. - Predictable LTS maintenance window aligns with Phase 1 delivery timelines.</p> <p>Negative: - Future upgrade path to next LTS (e.g., Java 21) will require dependency validation and performance testing. - Potential missed opportunities from newer language features in Java 21. - Larger memory footprint compared to more lightweight runtime alternatives.</p> <p>Mitigation Strategies: - Maintain compatibility matrix for critical libraries to track next LTS readiness. - Configure centralized build toolchains to ease future LTS upgrades. - Schedule regular evaluation of Java 21 adoption benefits and ecosystem readiness. - Implement performance benchmarks to measure upgrade impact.</p>"},{"location":"adr/ADR-0001-java-17-runtime/#revisit-trigger-and-target-sprint","title":"Revisit Trigger and Target Sprint","text":"<ul> <li>Revisit Trigger:</li> <li>All critical dependencies and tooling are certified on the next LTS (e.g., Java 21) and there is a measurable benefit (performance, maintainability, security).</li> <li>A scheduled upgrade window is available with capacity for comprehensive regression testing.</li> <li>Target Sprint:</li> <li>Sprint 1 (adoption finalized in Phase 1 foundations)</li> </ul>"},{"location":"adr/ADR-0001-java-17-runtime/#guardrails","title":"Guardrails","text":""},{"location":"adr/ADR-0001-java-17-runtime/#must","title":"Must","text":"<ul> <li>Use only LTS (Long Term Support) releases for JVM in production; never mix runtimes across services.</li> <li>Centralize all build (Gradle/Maven) configurations and container images; keep them version-locked and reviewed in CI.</li> <li>Track and document LTS readiness of all critical dependencies for upgrade planning.</li> <li>Require performance, regression, and compatibility testing for every runtime upgrade or change.</li> <li>Follow a standardized migration playbook for major Java upgrades, including rollback and validation steps.</li> </ul>"},{"location":"adr/ADR-0001-java-17-runtime/#should","title":"Should","text":"<ul> <li>Review ecosystem and dependency readiness for new Java releases at least quarterly.</li> <li>Document upgrade blockers and mitigation strategies before proposing LTS changes.</li> <li>Maintain uniform JVM and build tooling across environments (local/dev/CI/prod).</li> <li>Periodically benchmark services to assess future upgrade benefits and risks.</li> </ul>"},{"location":"adr/ADR-0001-java-17-runtime/#wont","title":"Won't","text":"<ul> <li>Allow ad-hoc runtime or toolchain changes without ADR-backed review and CI validation.</li> <li>Mix non-LTS Java or alternative JVM languages into the baseline without architectural approval.</li> <li>Perform major upgrades during critical delivery windows or without rollback planning.</li> </ul>"},{"location":"adr/ADR-0001-java-17-runtime/#approvals","title":"Approvals","text":"Review Reviewer Date (YYYY-MM-DD) Status Notes Architectural Review @MysterTech 2025-08-14 Approved Security Review @MysterTech 2025-08-14 Approved SRE Review @MysterTech 2025-08-14 Approved"},{"location":"adr/ADR-0001-java-17-runtime/#links","title":"Links","text":""},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/","title":"ADR-0002: R3 Corda 5 as DLT Platform","text":"<p>Author: @MysterTech Status: Accepted Date: 2025-08-13 Deciders: @MysterTech Technical Story: [optional link to ticket/issue] Tags: dlt, corda, blockchain</p>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#context","title":"Context","text":"<ul> <li>DealSphere platform requires a distributed ledger technology (DLT) platform for secure, tamper-proof transaction recording and multi-party business process execution.</li> <li>R3 Corda 5 provides enterprise-grade DLT capabilities specifically designed for regulated financial services and complex business networks.</li> <li>Team expertise includes blockchain development experience, and Corda's JVM-based architecture aligns with existing Java 17 runtime decisions.</li> <li>PRD alignment: Security requirements and regulatory compliance for financial transactions are prioritized for Phase 1 core flows.</li> </ul>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#decision","title":"Decision","text":"<p>Adopt R3 Corda 5 as the distributed ledger technology platform for DealSphere Phase 1.</p>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#rationale","title":"Rationale","text":""},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#why-r3-corda-5-as-dlt-platform","title":"Why R3 Corda 5 as DLT Platform?","text":"<p>Enterprise-Grade Security and Compliance: - Built-in privacy features with need-to-know data sharing principles. - Strong cryptographic foundations and secure communication protocols. - Regulatory compliance features aligned with financial services requirements. - Mature audit trails and transaction history capabilities.</p> <p>Technical Architecture Alignment: - JVM-based platform compatible with Java 17 runtime decision. - Spring Boot integration capabilities for microservices architecture. - REST and gRPC API support for seamless service integration. - Familiar development patterns reducing team onboarding overhead.</p> <p>Business Network Capabilities: - Multi-party transaction support essential for deal syndication workflows. - Smart contract (CorDapp) development for complex business logic. - Identity and certificate management for trusted counterparty networks. - Pluggable consensus mechanisms for different transaction types.</p> <p>Operational Maturity: - Production-ready platform with enterprise support options. - Comprehensive monitoring and observability tools integration. - Docker containerization support for Phase 1 orchestration strategy. - Established backup and disaster recovery patterns.</p> <p>Risk Management for Phase 1: - Proven track record in financial services implementations. - Active community and R3 support for issue resolution. - Clear upgrade paths and version compatibility strategies. - Minimizes experimental technology risk during initial platform delivery.</p> <p>Performance Characteristics: - Optimized for financial transaction throughput requirements. - Deterministic finality for transaction settlement scenarios. - Scalable node architecture supporting network growth. - Efficient resource utilization in containerized environments.</p>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#alternatives-considered","title":"Alternatives Considered","text":"<p>Hyperledger Fabric - Pros: Open-source platform with strong enterprise adoption. - Cons: More complex operational overhead; Go/Node.js ecosystem diverges from JVM stack; less financial services specific features. - Rejected: Does not align with JVM-based technology stack and financial services focus.</p> <p>Ethereum (Enterprise) - Pros: Large ecosystem and developer community. - Cons: Significant development and maintenance overhead; security risks from custom cryptography; delays Phase 1 delivery timeline. - Rejected: Too high risk and development overhead for Phase 1 timeline.</p>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#consequences","title":"Consequences","text":"<p>Positive: - DLT integration enables secure multi-party deal processing with cryptographic transaction integrity. - Corda's privacy model ensures sensitive deal information is only shared with relevant counterparties. - JVM-based development stack maintains consistency with Java 17 and microservices architecture decisions. - Enterprise-grade security and compliance features align with financial services requirements. - Established development patterns reduce team onboarding overhead.</p> <p>Negative: - Requires team training on Corda-specific concepts (states, flows, contracts) but leverages existing JVM skills. - Platform lock-in to R3 ecosystem and potential licensing costs. - Performance limitations compared to traditional databases for non-DLT operations. - Additional operational complexity for node management and network coordination.</p> <p>Mitigation Strategies: - Maintain abstraction layer between business logic and Corda-specific implementations. - Establish comprehensive training program for Corda development patterns. - Implement performance benchmarks and monitoring for transaction throughput. - Document all CorDapp development patterns and maintain code review standards.</p>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#revisit-trigger-and-target-sprint","title":"Revisit Trigger and Target Sprint","text":"<ul> <li> <p>Revisit Triggers:  </p> </li> <li> <p>Performance bottlenecks emerge that cannot be resolved through configuration or infrastructure scaling.  </p> </li> <li> <p>Regulatory requirements change significantly requiring features not available in Corda 5.  </p> </li> <li> <p>Major security vulnerabilities discovered that cannot be patched within acceptable timeframes.</p> </li> <li> <p>Target Sprint:  </p> </li> <li> <p>Sprint 1 (DLT platform foundation established in Phase 1)</p> </li> </ul>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#guardrails","title":"Guardrails","text":""},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#must","title":"Must","text":"<ul> <li>Maintain abstraction layer between business logic and Corda-specific implementations to enable future platform migration if needed.</li> <li>Establish performance benchmarks and monitoring for transaction throughput and latency.</li> <li>Keep Corda version compatibility matrix updated and plan regular security updates.</li> </ul>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#should","title":"Should","text":"<ul> <li>Document all CorDapp development patterns and maintain code review standards for smart contract logic.</li> <li>Implement comprehensive testing strategies for Corda flows and contracts.</li> </ul>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#wont","title":"Won't","text":"<ul> <li>Allow direct database access bypassing Corda's data model.</li> <li>Implement custom cryptographic solutions without R3 approval.</li> <li>Deploy CorDapps without proper code review and security assessment.</li> </ul>"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#approvals","title":"Approvals","text":"Review Reviewer Date (YYYY-MM-DD) Status Notes Architectural Review @MysterTech 2025-08-14 Approved Security Review @MysterTech 2025-08-14 Approved SRE Review @MysterTech 2025-08-14 Approved"},{"location":"adr/ADR-0002-r3-corda-5-dlt-platform/#links","title":"Links","text":"<p>Technology Landscape: [DLT Platform] Sprint Plan: [Sprint 1 \u2013 Core Platform Foundation] PRD: Security requirements and regulatory compliance </p> <p>Related ADRs: - ADR-0001: Java 17 as Language/Runtime </p>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/","title":"ADR-0003: Docker Compose for Phase 1 Orchestration","text":"<p>Author: @MysterTech    Status: Accepted     Date: 2025-08-13     Deciders: @MysterTech   Technical Story: Tags: orchestration, docker, compose    </p>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#context","title":"Context","text":"<ul> <li>DealSphere Phase 1 requires local development and integration testing environments that closely mirror production service topology.</li> <li>Docker Compose provides container orchestration capabilities suitable for multi-service development environments and CI/CD workflows.</li> <li>Team familiarity with containerization patterns and Docker ecosystem tools supports rapid adoption and troubleshooting.</li> <li>PRD alignment: Development workflow and deployment strategy are prioritized for Phase 1 delivery timelines.</li> </ul>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#decision","title":"Decision","text":"<p>Adopt Docker Compose as the container orchestration platform for DealSphere Phase 1 local development, testing, and CI/CD environments.</p>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#rationale","title":"Rationale","text":""},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#why-docker-compose-for-phase-1-orchestration","title":"Why Docker Compose for Phase 1 Orchestration?","text":"<p>Development Environment Consistency     - Standardized service configuration across all developer workstations.     - Reproducible dependency management for databases, message brokers, and external service mocks.     - Version-controlled environment definitions ensuring team alignment.     - Simple service lifecycle management (start/stop/restart) for rapid iteration.</p> <p>Integration Testing Support     - Multi-container test suites with predictable service startup ordering.     - Network isolation and service-to-service communication testing.     - Database and external service state management for test scenarios.     - CI/CD pipeline integration with consistent environment provisioning.</p> <p>Operational Simplicity     - Single-file service definitions (<code>docker-compose.yml</code>) for easy maintenance.     - Built-in service discovery and DNS resolution between containers.     - Volume mounting for development hot-reloading and persistent data.     - Log aggregation and debugging tools compatible with Docker ecosystem.</p> <p>Resource Management     - Efficient resource utilization on developer machines compared to VM-based alternatives.     - Fine-grained resource allocation per service (CPU/memory limits).     - Automatic cleanup and container lifecycle management.     - Minimal infrastructure overhead for local development workflows.</p> <p>Technology Stack Alignment     - Native Docker image support for Java 17 services and Spring Boot applications.     - PostgreSQL, Redis, and other backing service containers readily available.     - Corda node containerization patterns established in community.     - GraphQL and gRPC service containerization well-documented.</p> <p>CI/CD Integration     - GitHub Actions and other CI systems provide built-in Docker Compose support.     - Consistent environment definitions between local development and automated testing.     - Parallel service builds and testing capabilities.     - Easy integration with container registries for artifact management.</p>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#deferred-alternatives","title":"Deferred Alternatives","text":"<p>Kubernetes (Minikube/Kind)     - Pros: Production-like orchestration capabilities and advanced networking features.     - Cons: Significantly higher complexity for Phase 1 scope; resource overhead; learning curve.</p>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#rejected-alternatives","title":"Rejected Alternatives","text":"<p>VM-based Development     - Pros: Complete isolation and familiar virtualization patterns.     - Cons: Higher resource consumption; slower startup; complex dependency management.</p> <p>Manual Service Management     - Pros: Direct control over configuration and debugging.     - Cons: Inconsistent environments; complex coordination; difficult integration testing.</p>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#consequences","title":"Consequences","text":"<ul> <li>Positive:<ul> <li>Standardized environments reduce \"works on my machine\" issues and improve team productivity.</li> <li>Multi-service integration testing is reliable and reproducible.</li> <li>Container-based architecture provides a foundation for future Kubernetes migration.</li> </ul> </li> <li>Negative:<ul> <li>Requires all team members to have Docker knowledge.</li> </ul> </li> <li>Mitigation Strategies:<ul> <li>Provide comprehensive Docker/containerization training.</li> <li>Create detailed documentation for common workflows/troubleshooting.</li> <li>Establish service configuration/resource allocation guidelines.</li> </ul> </li> </ul>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#revisit-trigger-and-target-sprint","title":"Revisit Trigger and Target Sprint","text":"<ul> <li>Revisit Trigger:<ul> <li>Service scaling needs exceed single-machine capabilities.</li> <li>Production needs require advanced orchestration (service mesh, networking, etc.).</li> <li>Team size growth complicates coordination.</li> </ul> </li> <li>Target Sprint:<ul> <li>Sprint 1 (orchestration foundation established for Phase 1).</li> </ul> </li> </ul>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#guardrails","title":"Guardrails","text":""},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#must","title":"Must","text":"<ul> <li>Maintain environment parity between Docker Compose configurations and production deployments.</li> <li>Document service interdependencies and startup ordering in compose files.</li> <li>Set resource limits and health checks for all services.</li> <li>Keep configurations version-controlled and synchronized.</li> </ul>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#should","title":"Should","text":"<ul> <li>Review Docker Compose and service dependency documentation quarterly.</li> <li>Automate health checks and resource limit validation in CI workflows.</li> <li>Peer-review all configuration changes before merging to main branch.</li> </ul>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#wont","title":"Won't","text":"<ul> <li>Allow undocumented ad-hoc configuration changes.</li> <li>Permit divergence between development and production orchestration files without explicit architectural review.</li> <li>Support container versions/services that lack defined health checks or resource limits.</li> </ul>"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#approvals","title":"Approvals","text":"Review Reviewer Date (YYYY-MM-DD) Status Notes Architectural Review @MysterTech 2025-08-14 Approved Security Review @MysterTech 2025-08-14 Approved SRE Review @MysterTech 2025-08-14 Approved"},{"location":"adr/ADR-0003-docker-compose-phase1-orchestration/#links","title":"Links","text":"<ul> <li>Technology Landscape: [Orchestration Platform]</li> <li>Sprint Plan: [Sprint 1 \u2013 Development Environment Setup]</li> <li>Related ADRs:<ul> <li>ADR-0001: Java 17 as Language/Runtime</li> </ul> </li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/","title":"ADR-0004: Service Framework Default Selection","text":"<p>Author: @MysterTech Status: Accepted Date: 2025-08-13 Deciders: @MysterTech Technical Story: [optional link to ticket/issue] Tags: framework, dgs, graphql, services  </p>"},{"location":"adr/ADR-0004-service-framework-defaults/#context","title":"Context","text":"<ul> <li>Services are being bootstrapped with divergent patterns (project structure, configuration, security, telemetry), leading to inconsistent realization of core Phase 1 capabilities (permissions, documents, capital calls, waterfalls, workflows, analytics, accounting, portfolio, AI), and increasing integration risk.</li> <li>Cross-cutting functional needs mandated by the PRD\u2014strict role/class-based access, encrypted storage with hash verification, workflow SLAs and escalations, deterministic financial calculations, auditability, and API-first integrations are re-implemented differently across services, causing uneven behavior and slowing end-to-end validation.</li> <li>Inconsistent build/run conventions impede CI/CD policy enforcement required to meet PRD acceptance criteria (e.g., schema governance, security scans, performance/SLO checks, deterministic outputs for waterfalls, class segregation in AI and analytics).</li> <li>Developer onboarding and delivery velocity suffer because contributors must relearn patterns per service, delaying PRD milestones and increasing review/defect cycles.</li> <li>Phase 1 requires predictable, testable, and operable services across multiple domains and sprints; without shared defaults and guardrails, class-segregated flows (RBAC, documents, capital calls, waterfalls, workflows) and their acceptance criteria are harder to deliver reliably.</li> </ul> <p>Therefore, this ADR proposes establishing minimal, opinionated defaults and starter templates focused on PRD needs:</p> <ul> <li>Security &amp; Access: uniform authentication/authorization with strict class-level segregation and auditability.</li> <li>Data &amp; Documents: standardized configuration for encrypted storage, on-ledger metadata, content hash verification, and versioning/audit logs.</li> <li>Observability: consistent logs/metrics/traces with baseline dashboards/alerts to validate SLAs, workflow latencies, and compliance signals.</li> <li>Resiliency: timeouts, retries, circuit breakers, backoff, idempotency patterns to support workflow reliability and external integrations.</li> <li>Deterministic Calculations: conventions for numeric precision and validation harnesses to meet waterfall test vectors and accounting accuracy.</li> <li>CI/CD &amp; Quality: consistent build/test conventions, static analysis, coverage, schema checks, supply-chain security, and performance gates aligned to acceptance criteria.</li> <li>Interfaces &amp; Contracts: API/schema standards and error contracts to support API-first integrations and PRD traceability.</li> <li>Developer Workflow: coherent local dev, testing, and documentation to reduce time-to-first-commit and hit sprint timelines.</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#decision","title":"Decision","text":"<p>Adopt Netflix DGS (GraphQL Java with DGS) as the default service framework for Phase 1 services, with standardized starter configurations and common patterns.</p>"},{"location":"adr/ADR-0004-service-framework-defaults/#rationale","title":"Rationale","text":""},{"location":"adr/ADR-0004-service-framework-defaults/#why-netflix-dgs-service-framework-default-selection","title":"Why Netflix DGS (Service Framework Default Selection)","text":"<p>Stability and Support</p> <ul> <li>GraphQL-first schema-driven development reduces boilerplate and accelerates service scaffolding</li> <li>Rich ecosystem of DGS features covers common requirements (code generation, schema registry, federation)</li> <li>Built-in observability (GraphQL instrumentation, metrics, health checks, logging)</li> <li>Native GraphQL federation support enables distributed schema composition and seamless gateway integration</li> </ul> <p>Ecosystem Readiness</p> <ul> <li>Consistent GraphQL patterns across services reduce context switching and onboarding time</li> <li>Mature tooling integration (schema linting, breaking-change detection, IDE support)</li> <li>Performance optimizations through data loader patterns and query cost analysis</li> </ul> <p>Team Proficiency and Velocity</p> <ul> <li>Standardized GraphQL development patterns across all microservices</li> <li>Reduced configuration drift through DGS code generation and schema registry integration</li> <li>Clear upgrade paths and long-term support from Netflix</li> </ul> <p>Modern Features without migration burden</p> <ul> <li>Security at GraphQL layer through authorization directives and middlewares</li> <li>Established patterns for query/mutation/subscription handling and federation/gateway compatibility</li> <li>Strong community support and comprehensive documentation</li> </ul> <p>Risk Management</p> <ul> <li>Accelerated development velocity for Phase 1 delivery</li> <li>GraphQL query cost limits and depth/complexity analysis for performance tuning</li> <li>Proven track record in similar microservices architectures at Netflix scale</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#rejected-alternatives","title":"Rejected Alternatives","text":"<ul> <li>Spring Boot</li> <li>Reason for rejection: Rich ecosystem and team expertise, but adopting DGS focuses service delivery on GraphQL-first architecture, federation, and schema-driven contracts without additional REST overhead.</li> <li> <p>Reconsider if: REST-centric needs or gaps in DGS ecosystem for critical features arise after Phase 1.</p> </li> <li> <p>Quarkus</p> </li> <li>Reason for rejection: Fast startup and native compilation attractive, but extra learning curve and ecosystem risk during initial delivery; DGS better aligns with immediate GraphQL federation priorities.</li> <li> <p>Reconsider if: Post-Phase 1, performance profiling shows that native compilation or Quarkus features bring clear, material benefits.</p> </li> <li> <p>Micronaut</p> </li> <li>Reason for rejection: Lightweight and fast but adds framework diversity without decisive advantages for GraphQL and federation over DGS, reducing standardization.</li> <li>Reconsider if: Team expertise or service requirements shift in Micronaut's favor, or unique features are required later.</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#consequences","title":"Consequences","text":"<p>Positive:</p> <ul> <li>Standardized GraphQL development patterns across all microservices</li> <li>Reduced configuration drift through DGS code generation and schema registry integration</li> <li>Leveraged GraphQL ecosystem for query/mutation/subscription patterns and federation compatibility</li> <li>Accelerated development velocity for Phase 1 delivery through schema-driven development</li> <li>Consistent GraphQL instrumentation and observability across services</li> <li>Enhanced API contracts through GraphQL schema-first approach</li> <li>Improved pagination and caching patterns through GraphQL best practices</li> <li>Performance tuning capabilities with query cost limits and depth/complexity analysis</li> </ul> <p>Negative:</p> <ul> <li>Potential vendor lock-in to Netflix DGS ecosystem</li> <li>May not be optimal for non-GraphQL or high-throughput REST use cases</li> <li>Framework upgrade dependencies across multiple services</li> <li>Learning curve for teams unfamiliar with GraphQL patterns</li> </ul> <p>Mitigation Strategies:</p> <ul> <li>Maintain service interface contracts independent of framework implementation</li> <li>Use GraphQL schema-first approaches to reduce coupling to specific implementations</li> <li>Document migration patterns for future framework transitions</li> <li>Implement CI checks for schema linting and breaking-change detection</li> <li>Establish federation/gateway compatibility for gradual framework updates</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#revisit-triggers","title":"Revisit Triggers","text":"<ul> <li>Performance bottlenecks identified in Phase 1 services</li> <li>Team expertise shifts significantly toward alternative frameworks</li> <li>Major Netflix DGS security vulnerabilities or end-of-life announcements</li> <li>GraphQL ecosystem shifts requiring different tooling approaches</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#target-sprint-for-formal-decision","title":"Target Sprint for Formal Decision","text":"<p>Target Sprint: Sprint 1</p>"},{"location":"adr/ADR-0004-service-framework-defaults/#guardrails","title":"Guardrails","text":""},{"location":"adr/ADR-0004-service-framework-defaults/#must","title":"Must","text":"<ul> <li>All new services must use approved Netflix DGS starter templates</li> <li>Framework deviations require architecture review and explicit approval</li> <li>GraphQL schema contracts must follow federation/gateway compatibility standards</li> <li>Performance benchmarks must meet Phase 1 SLA requirements with query cost limits</li> <li>CI checks must include schema linting and breaking-change detection</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#should","title":"Should","text":"<ul> <li>Follow Netflix DGS best practices for GraphQL schema design and code generation</li> <li>Implement standardized GraphQL instrumentation and observability patterns</li> <li>Use authorization directives and middlewares for security at GraphQL layer</li> <li>Apply data loader patterns for efficient data fetching</li> <li>Implement proper pagination and caching patterns</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#wont","title":"Won't","text":"<ul> <li>Custom GraphQL implementations without architectural approval</li> <li>Framework mixing within individual services</li> <li>Bypassing established Netflix DGS patterns without justification</li> <li>Schema changes without proper versioning and breaking-change analysis</li> </ul>"},{"location":"adr/ADR-0004-service-framework-defaults/#approvals","title":"Approvals","text":"Review Reviewer Date (YYYY-MM-DD) Status Notes Architectural Review @MysterTech 2025-08-14 Approved Security Review @MysterTech 2025-08-14 Approved SRE Review @MysterTech 2025-08-14 Approved"},{"location":"adr/ADR-0004-service-framework-defaults/#links","title":"Links","text":"<p>Review Before Deciding: - Netflix DGS Documentation: Developer docs</p> <p>Technology Landscape: [Tech Landscape Document]</p> <p>Product/PRD: Phase 1 PRD - Service Framework</p> <p>Sprint Plan: [Link to sprint planning documentation]</p> <p>Related ADRs: - ADR-0001: Microservices Architecture - Establishes distributed system foundation</p>"},{"location":"planning/delivery-plan-12weeks-tdd/","title":"12-Week MVP Delivery Plan (TDD Approach)","text":"<p>This plan breaks the MVP delivery into six 2-week sprints. Each sprint is defined by an epic, a set of stories (major tasks), and explicit deliverables that must be achieved for a sprint to be considered \u201cdone.\u201d All work must be validated by passing tests, demos, and CI/CD artefacts.</p>"},{"location":"planning/delivery-plan-12weeks-tdd/#sprint-1-weeks-12-core-framework-auth","title":"Sprint 1 (Weeks 1\u20132): Core Framework &amp; Auth","text":""},{"location":"planning/delivery-plan-12weeks-tdd/#stories","title":"Stories","text":"<ul> <li>Project repo setup (backend, frontend, Docker Compose, DB, initial CI/CD pipeline)</li> <li>Code style, linting, and TDD test framework (Java/React)</li> <li>User authentication (Login/Logout)</li> <li>Role/permission model setup and TDD</li> <li>Negative/abuse authentication and permission tests</li> <li>Dev/staging environments and build artefact validation</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#deliverables","title":"Deliverables","text":"<ul> <li>CI pipeline running with all checks</li> <li>Docker Compose brings up all services in local/dev</li> <li>Passing unit/integration tests for authentication/RBAC</li> <li>Demo: User login/logout via UI and backend API</li> <li>\"Green\" RBAC/auth checks in test suite</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#sprint-2-weeks-34-user-mgmt-documents","title":"Sprint 2 (Weeks 3\u20134): User Mgmt &amp; Documents","text":""},{"location":"planning/delivery-plan-12weeks-tdd/#stories_1","title":"Stories","text":"<ul> <li>Complete User CRUD (API &amp; UI) with full RBAC enforcement</li> <li>Document upload/download (S3/MinIO integration)</li> <li>Document metadata, versioning, and audit log</li> <li>Document access restrictions (class/role/ownership)</li> <li>Negative/edge document flows</li> <li>Doc AI/categorization prototype</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#deliverables_1","title":"Deliverables","text":"<ul> <li>User management UI/API running and tested</li> <li>Document workflow (upload, version, access, audit) demoable</li> <li>Document access strictly enforced by RBAC</li> <li>Unit/integration tests green for user/document modules</li> <li>Audit logs and doc AI/categorization prototype in dev</li> <li>Demoable user and document features</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#sprint-3-weeks-56-capital-call-waterfall","title":"Sprint 3 (Weeks 5\u20136): Capital Call &amp; Waterfall","text":""},{"location":"planning/delivery-plan-12weeks-tdd/#stories_2","title":"Stories","text":"<ul> <li>Capital call create/view/update (UI and API)</li> <li>Notification integration (email/in-app)</li> <li>Waterfall model design (algorithms, DB)</li> <li>Waterfall calculation/unit allocation features</li> <li>Negative/corner capital call and waterfall tests</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#deliverables_2","title":"Deliverables","text":"<ul> <li>Capital call workflow (from create to notification) demoable</li> <li>Waterfall logic for PRD scenarios covered and tested</li> <li>Notifications firing in all intended scenarios</li> <li>Passing end-to-end/negative tests for capital call &amp; waterfall</li> <li>Demo of capital call + waterfall, start to finish</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#sprint-4-weeks-78-workflow-automation-integrations","title":"Sprint 4 (Weeks 7\u20138): Workflow Automation &amp; Integrations","text":""},{"location":"planning/delivery-plan-12weeks-tdd/#stories_3","title":"Stories","text":"<ul> <li>Approval, reminders, SLA scheduler for workflow</li> <li>Workflow state transitions (approval \u2192 notification \u2192 escalation)</li> <li>AI-assisted capital call/doc query implementation</li> <li>R3 Corda integration stub/mock (main flows + error cases)</li> <li>Integration/edge tests for AI, Corda, bank API</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#deliverables_3","title":"Deliverables","text":"<ul> <li>Automated workflow demo (with SLAs/triggers)</li> <li>Integration stubs working for all major paths</li> <li>E2E, workflow &amp; integration tests passing in CI</li> <li>Demo: approvals/escalation in test/stage</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#sprint-5-weeks-910-accounting-analytics-portfolio","title":"Sprint 5 (Weeks 9\u201310): Accounting, Analytics, Portfolio","text":""},{"location":"planning/delivery-plan-12weeks-tdd/#stories_4","title":"Stories","text":"<ul> <li>Fund ledger, NAV calculation, reports UI</li> <li>Analytics dashboards, role-based views, CSV export</li> <li>Portfolio/company/investment tracking screens</li> <li>Data integrity/reporting edge tests</li> <li>Cross-role analytics validation</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#deliverables_4","title":"Deliverables","text":"<ul> <li>Analytics/reporting UI shows real/test data</li> <li>Portfolio/accounting screens tested, working</li> <li>CSV export/bulk data tested for all grids</li> <li>Acceptance/unit/integration tests pass for metrics, portfolio</li> <li>Demo: analytics, reporting, and portfolio features</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#sprint-6-weeks-1112-e2e-security-launch-ready","title":"Sprint 6 (Weeks 11\u201312): E2E, Security, Launch-Ready","text":""},{"location":"planning/delivery-plan-12weeks-tdd/#stories_5","title":"Stories","text":"<ul> <li>Full end-to-end UI automation (Cypress/Playwright)</li> <li>Security, RBAC bypass, and abuse/edge case tests</li> <li>Load/smoke/restore test scripts &amp; backup/restore process validation</li> <li>Performance &amp; non-functional: failover and basic regression</li> <li>Polishing, bug fixes, final checks, and code freeze</li> <li>Freeze/publish all architecture/release/deployment docs</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#deliverables_5","title":"Deliverables","text":"<ul> <li>End-to-end automated test journeys \u201cgreen\u201d for all critical flows</li> <li>Security, load, failover, restore, and abuse tests pass</li> <li>All critical path test cases pass (functional, integration, security)</li> <li>Demo complete MVP user flows per persona</li> <li>Launch checklist and final documentation published</li> </ul>"},{"location":"planning/delivery-plan-12weeks-tdd/#usage-notes","title":"Usage Notes","text":"<ul> <li>Each sprint is \u201cdone\u201d only when all stories are completed and deliverables demonstrably met.</li> <li>Always validate by demo and passing CI/CD tests.</li> <li>If features spill to the next sprint, update scope and priorities in this document.</li> </ul> <p>Last updated: August 2025</p>"},{"location":"planning/phase1-epics/","title":"Phase 1 Epics: Weekly Tech Deliverables Guide","text":"<p>This document provides a week-by-week breakdown of all core tech deliverables for Phase 1 of DealSphere, ensuring that every business-critical capability from the PRD and all functional test cases are tracked and completed. Each Epic summarizes a vertical slice (major user-facing/integrated feature set) and links every deliverable to specific functional test cases. Use this guide as the master reference for sprint planning, tracking, and acceptance\u2014each Story or Deliverable is \u201cDone\u201d when all linked test cases are passing in CI.</p> Epic (Weeks) Story / Deliverable Linked Functional Test Cases Core Framework &amp; Auth (1\u20132) Repo, CI pipeline, Docker Compose setup -- User authentication (Login/Logout) 1.1.1, 1.1.2, 1.1.5, 1.2.5 Role/permission model setup, TDD tests 1.1.3, 1.1.6, 1.1.7 Basic negative/abuse auth tests 1.2.1, 1.2.2, 1.2.3 User Mgmt &amp; Documents (3\u20134) User CRUD (API &amp; UI), RBAC enforcement 1.1.x, 1.3.2 Document upload/download, S3/MinIO integration 2.1.1, 2.1.2, 2.1.4 Document metadata, versioning, audit log 2.1.3, 2.2.1\u20132.2.4 Doc access restriction tests 2.1.4 Basic doc AI/categorization test stub 2.3.1\u20132.3.3 Capital Call &amp; Waterfall (5\u20136) Capital call create/view/update 3.1.1\u20133.1.4, 3.2.1\u20133.2.3 Notification integration (email/in-app) 3.1.3, 3.2.3 Waterfall model scaffolding 4.1.1\u20134.1.3, 4.2.1\u20134.2.3 Waterfall calculation, unit allocation 4.3.1\u20134.3.4 Capital call/Waterfall negative/edge case tests 3.3.1\u20133.3.3, 4.2.4 Workflow Automation &amp; Integrations (7\u20138) Approval, reminder, SLA scheduler 5.1.1\u20135.1.3, 5.2.1\u20135.2.2 AI-assisted capital call, doc query iteration 7.1.1\u20137.1.3, 2.3.1\u20132.3.3 R3 Corda stub integration 1.3.1\u20131.3.3 Integration/edge tests for AI/Corda 8.2.1\u20138.2.3 Accounting, Analytics, Portfolio (9\u201310) Fund ledger, NAV, report UI &amp; export 6.1.1\u20136.1.4, 9.1.1\u20139.1.4 Analytics dashboards and role-based views 6.2.1\u20136.2.3, 10.1.1\u201310.1.3 Portfolio and company tracking 10.2.1\u201310.2.3, 10.3.1 E2E, Security, Launch-Ready (11\u201312) End-to-end UI flow automation ALL major functional test cases Security/negative tests (abuse, failover, RBAC) 1.2.4, 1.3.3, 8.1.1\u20138.1.3 Load/smoke/restore tests, backup-restore 8.3.1, 8.3.2, 8.3.3, 8.3.4 Final non-functional and regression suite ALL <p>How to use this document:</p> <ul> <li>Sprint Planning: Assign stories/deliverables week by week, referencing test cases to ensure test-driven development and coverage.</li> <li>Tracking Progress: Check off epics and stories as their corresponding test cases pass\u2014all features are \u201cDone\u201d only when verified by passing tests.</li> <li>Review &amp; Adjust: Re-align deliverables or epics as priorities shift in the MVP build, ensuring that every functional and technical goal remains traceable.</li> <li>Traceability: If new features/test cases are added, extend the table and epics so the plan always aligns with current project reality.</li> </ul> <p>For questions, proposed changes, or refinement, update this doc and communicate with the DealSphere tech and QA teams.</p>"},{"location":"product/Phase1_PRD/","title":"DealSphere Phase 1 (MVP) \u2014 Product Requirements Document","text":""},{"location":"product/Phase1_PRD/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Product Overview </li> <li>Target Users </li> <li>Core Use Cases </li> <li>Feature Requirements (Phase 1)      4.1. Platform &amp; Security     4.2. Document Management      4.3. Capital Calls      4.4. Waterfall Calculations (Multi-Class)      4.5. Workflow Automation (Per Class)      4.6. Basic Analytics      4.7. AI Integration (Initial)      4.8. Architecture Design      4.9. Fund Accounting      4.10. Portfolio Tracking </li> <li>Non-Functional Requirements </li> <li>Acceptance Criteria (Key) </li> <li>Success Metrics </li> <li>Risks &amp; Mitigation </li> <li>Timeline (Sprint Breakdown) </li> <li>QA Documentation </li> </ol> <p>Related Documents:</p>"},{"location":"product/Phase1_PRD/#1-product-overview","title":"1. Product Overview","text":"<ul> <li>Product Name: DealSphere</li> <li>Description: Secure, DLT-backed fund management platform for PE/VC with class-specific workflows and automated waterfalls, built on R3 Corda.</li> <li>Objective: Deliver an MVP that supports multi-class fund operations (permissions, capital calls, workflows, waterfalls), basic analytics, fund accounting, and portfolio tracking with AI-assisted experiences and a finalized architecture for scale.</li> </ul>"},{"location":"product/Phase1_PRD/#2-target-users","title":"2. Target Users","text":"<ul> <li>General Partners (GP), Limited Partners (LP) by class (A, B, etc.)</li> <li>Fund Managers and Administrators</li> <li>Auditors and Compliance users</li> <li>Investment/Portfolio Analysts</li> <li>Investors (read-only class-specific views)</li> <li>AI Assistant (virtual role for automated tasks)</li> </ul>"},{"location":"product/Phase1_PRD/#3-core-use-cases","title":"3. Core Use Cases","text":"<ul> <li>Role-based, class-segregated access and views</li> <li>Document management with on-ledger metadata, versioning, and audit logs</li> <li>Capital call lifecycle per class (rules, notices, tracking)</li> <li>Multi-class European and American waterfalls with prioritization and clawbacks</li> <li>Class-specific workflow automation (approvals, reminders, escalations)</li> <li>Basic analytics by class (committed vs. deployed, portfolio breakdown)</li> <li>Fund accounting and NAV/P&amp;L at class and combined levels</li> <li>Portfolio tracking with class-based contributions and returns</li> <li>AI-assisted class-specific queries and drafting</li> </ul>"},{"location":"product/Phase1_PRD/#4-feature-requirements-phase-1","title":"4. Feature Requirements (Phase 1)","text":""},{"location":"product/Phase1_PRD/#41-platform-security","title":"4.1 Platform &amp; Security","text":"<ul> <li>Role-based access control (RBAC) with strict class segregation</li> <li>R3 Corda DLT integration for immutable audit trails</li> <li>Multi-tenant architecture supporting multiple funds</li> <li>Encryption at rest and in transit</li> <li>Compliance framework (GDPR, SOX, regional requirements)</li> </ul>"},{"location":"product/Phase1_PRD/#42-document-management","title":"4.2 Document Management","text":"<ul> <li>Upload, version, and categorize documents per class</li> <li>On-ledger metadata storage with hash verification</li> <li>Access controls ensuring LP class segregation</li> <li>Document templates and automated generation</li> <li>Full audit logs for document lifecycle events</li> </ul>"},{"location":"product/Phase1_PRD/#43-capital-calls","title":"4.3 Capital Calls","text":"<ul> <li>Class-specific capital call rules and thresholds</li> <li>Automated notice generation and distribution per class</li> <li>Payment tracking and reconciliation by class</li> <li>Default management and escalation workflows</li> <li>Integration with banking APIs for payment verification</li> </ul>"},{"location":"product/Phase1_PRD/#44-waterfall-calculations-multi-class","title":"4.4 Waterfall Calculations (Multi-Class)","text":"<ul> <li>European and American waterfall models</li> <li>Class-based priority and allocation rules</li> <li>Clawback provisions and carry calculations</li> <li>Real-time distribution modeling and simulation</li> <li>Support for preferred returns and catch-up provisions</li> </ul>"},{"location":"product/Phase1_PRD/#45-workflow-automation-per-class","title":"4.5 Workflow Automation (Per Class)","text":"<ul> <li>Class-specific approval workflows</li> <li>Automated reminders and escalations</li> <li>Task assignment and tracking per class</li> <li>SLA monitoring and reporting</li> <li>Integration with email and notification systems</li> </ul>"},{"location":"product/Phase1_PRD/#46-basic-analytics","title":"4.6 Basic Analytics","text":"<ul> <li>Class-based committed vs. deployed capital tracking</li> <li>Portfolio performance breakdown by class</li> <li>Cash flow projections per class</li> <li>Basic reporting and export functionality</li> <li>Real-time dashboard views segregated by class</li> </ul>"},{"location":"product/Phase1_PRD/#47-ai-integration-initial","title":"4.7 AI Integration (Initial)","text":"<ul> <li>AI-assisted document drafting with class-specific parameters</li> <li>Intelligent data extraction from uploaded documents</li> <li>Class-aware query processing and responses</li> <li>Automated categorization and tagging</li> <li>Compliance checking and risk flagging</li> </ul>"},{"location":"product/Phase1_PRD/#48-architecture-design","title":"4.8 Architecture Design","text":"<ul> <li>Microservices architecture with API-first approach</li> <li>Cloud-native deployment (AWS/Azure/GCP)</li> <li>Scalable data architecture supporting multi-class operations</li> <li>API gateway for integrations and external services</li> <li>Security model for strict class-based segregation and audit</li> </ul>"},{"location":"product/Phase1_PRD/#49-fund-accounting","title":"4.9 Fund Accounting","text":"<ul> <li>Multi-class general ledger</li> <li>NAV and P&amp;L per class and combined</li> </ul>"},{"location":"product/Phase1_PRD/#410-portfolio-tracking","title":"4.10 Portfolio Tracking","text":"<ul> <li>Company profiles with investment history split by class</li> <li>Performance metrics per class and consolidated views</li> </ul>"},{"location":"product/Phase1_PRD/#5-non-functional-requirements","title":"5. Non-Functional Requirements","text":"<ul> <li>Mobile-responsive web app</li> <li>High security: DLT auditability, encryption, RBAC with class segregation</li> <li>GDPR-ready and regional compliance placeholders</li> <li>Cloud deployment (AWS/Azure/GCP)</li> <li>API-first for integrations and modular scale</li> </ul>"},{"location":"product/Phase1_PRD/#6-acceptance-criteria-key","title":"6. Acceptance Criteria (Key)","text":"<ul> <li>Permissions: LPs see only their class; adjustable without contract redeploy</li> <li>Documents: Versioning works; access logs accurate; hash verification consistent</li> <li>Capital Calls: Issued per class rules; LP payment statuses update correctly</li> <li>Waterfalls: Distributions per class match test vectors; switching preserves class logic</li> <li>Workflows: Class A and B flows run concurrently without conflict; reminders as configured</li> <li>Analytics: Reports filterable by class; exports work</li> <li>AI: Filters/outputs adhere to class constraints; drafts match class parameters</li> <li>Accounting: NAV computed separately by class and combined</li> <li>Portfolio: Class-specific contributions and returns displayed</li> </ul>"},{"location":"product/Phase1_PRD/#7-success-metrics","title":"7. Success Metrics","text":"<ul> <li>Funds onboarded leveraging multi-class features</li> <li>Volume of class-specific capital calls and distributions</li> <li>Workflow automation throughput and SLA adherence</li> <li>Accuracy of waterfall outputs vs. expected vectors</li> <li>Frequency of AI-assisted actions</li> <li>Analytics/export usage by class</li> </ul>"},{"location":"product/Phase1_PRD/#8-risks-mitigation","title":"8. Risks &amp; Mitigation","text":"<ul> <li>Multi-class complexity: Test vectors and simulation harnesses</li> <li>Security/segregation: Pen testing, rigorous data access validation, on-ledger audit</li> <li>Scope creep: Phased deliveries with strict change control</li> <li>Compliance variance: Region placeholders and pilot validation</li> </ul>"},{"location":"product/Phase1_PRD/#9-timeline-sprint-breakdown","title":"9. Timeline (Sprint Breakdown)","text":""},{"location":"product/Phase1_PRD/#10-qa-documentation","title":"10. QA Documentation","text":"<p>Summary: Phase 1 delivers a secure, multi-class MVP across permissions, documents, capital calls, waterfalls, workflows, analytics, fund accounting, and portfolio tracking, with AI assist and an architecture ready for scale.</p>"},{"location":"qa/Phase1_Functional_Test_Cases/","title":"Phase 1 Functional Test Cases","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#overview","title":"Overview","text":"<p>This document outlines the functional test cases for DealSphere Phase 1 (MVP) based on the requirements defined in Phase1_PRD.md. These test cases cover all core functional areas with class-specific multi-tenant functionality.</p> <p>Related Documents: - Phase1_PRD.md</p>"},{"location":"qa/Phase1_Functional_Test_Cases/#1-platform-security","title":"1. Platform &amp; Security","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#11-role-based-access-control-rbac","title":"1.1 Role-Based Access Control (RBAC)","text":"<ul> <li>Test Case 1.1.1: Verify Admin users can access all fund classes and system configurations</li> <li>Test Case 1.1.2: Verify GP users can access all fund operations within their assigned funds</li> <li>Test Case 1.1.3: Verify LP Class A users can only access Class A-specific data and documents</li> <li>Test Case 1.1.4: Verify LP Class B users can only access Class B-specific data and documents</li> <li>Test Case 1.1.5: Verify Auditor users can access read-only views across all classes for audit purposes</li> <li>Test Case 1.1.6: Verify AI Assistant can access data according to class-specific permissions for automated tasks</li> <li>Test Case 1.1.7: Verify permission changes are enforced without contract redeployment</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#12-security-encryption","title":"1.2 Security &amp; Encryption","text":"<ul> <li>Test Case 1.2.1: Verify all data is encrypted at rest using approved encryption standards</li> <li>Test Case 1.2.2: Verify all data transmission is encrypted in transit</li> <li>Test Case 1.2.3: Verify content hash verification works for document integrity</li> <li>Test Case 1.2.4: Verify secure node topology prevents unauthorized access</li> <li>Test Case 1.2.5: Verify API gateway enforces authentication and authorization</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#13-r3-corda-integration","title":"1.3 R3 Corda Integration","text":"<ul> <li>Test Case 1.3.1: Verify on-ledger access control metadata is properly maintained</li> <li>Test Case 1.3.2: Verify Corda node handles multi-class transactions correctly</li> <li>Test Case 1.3.3: Verify ledger integrity and audit trail functionality</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#2-document-management","title":"2. Document Management","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#21-document-storage-metadata","title":"2.1 Document Storage &amp; Metadata","text":"<ul> <li>Test Case 2.1.1: Verify documents are stored with encrypted off-ledger storage</li> <li>Test Case 2.1.2: Verify on-ledger metadata is correctly maintained for all documents</li> <li>Test Case 2.1.3: Verify content hash verification detects document tampering</li> <li>Test Case 2.1.4: Verify class-specific document access restrictions</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#22-version-control-audit-logging","title":"2.2 Version Control &amp; Audit Logging","text":"<ul> <li>Test Case 2.2.1: Verify document version control tracks all changes with timestamps</li> <li>Test Case 2.2.2: Verify audit logging captures all document access events</li> <li>Test Case 2.2.3: Verify access logs show user identity, timestamp, and action performed</li> <li>Test Case 2.2.4: Verify version history is maintained across document updates</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#23-ai-enhanced-document-features","title":"2.3 AI-Enhanced Document Features","text":"<ul> <li>Test Case 2.3.1: Verify smart search returns relevant documents based on class permissions</li> <li>Test Case 2.3.2: Verify OCR-based document classification works accurately</li> <li>Test Case 2.3.3: Verify AI classification respects class-based document segregation</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#3-capital-calls","title":"3. Capital Calls","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#31-class-specific-capital-call-rules","title":"3.1 Class-Specific Capital Call Rules","text":"<ul> <li>Test Case 3.1.1: Verify capital call rules can be configured separately for each class</li> <li>Test Case 3.1.2: Verify capital call percentages are applied correctly per class</li> <li>Test Case 3.1.3: Verify capital call schedules work independently for different classes</li> <li>Test Case 3.1.4: Verify smart contract templates generate class-appropriate notices</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#32-payment-tracking-status-updates","title":"3.2 Payment Tracking &amp; Status Updates","text":"<ul> <li>Test Case 3.2.1: Verify automated payment tracking works per LP and per class</li> <li>Test Case 3.2.2: Verify LP payment status updates are accurate and timely</li> <li>Test Case 3.2.3: Verify payment status is only visible to authorized class members</li> <li>Test Case 3.2.4: Verify automated reminders are sent according to class-specific schedules</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#33-capital-call-lifecycle","title":"3.3 Capital Call Lifecycle","text":"<ul> <li>Test Case 3.3.1: Verify capital call notices are generated with correct class parameters</li> <li>Test Case 3.3.2: Verify enforcement mechanisms work per class rules</li> <li>Test Case 3.3.3: Verify escalation procedures follow class-specific SLAs</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#4-waterfall-calculations","title":"4. Waterfall Calculations","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#41-multi-class-european-waterfall","title":"4.1 Multi-Class European Waterfall","text":"<ul> <li>Test Case 4.1.1: Verify European waterfall calculates whole-of-fund distributions correctly</li> <li>Test Case 4.1.2: Verify class-specific preferred returns are applied accurately</li> <li>Test Case 4.1.3: Verify catch-up calculations work correctly for each class</li> <li>Test Case 4.1.4: Verify carry calculations are applied per class parameters</li> <li>Test Case 4.1.5: Verify inter-class priority is respected in distribution calculations</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#42-multi-class-american-waterfall","title":"4.2 Multi-Class American Waterfall","text":"<ul> <li>Test Case 4.2.1: Verify American waterfall processes deal-by-deal distributions correctly</li> <li>Test Case 4.2.2: Verify class-specific clawback logic is applied appropriately</li> <li>Test Case 4.2.3: Verify deal-level distributions respect class-specific parameters</li> <li>Test Case 4.2.4: Verify clawback calculations are accurate per class rules</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#43-waterfall-configuration-switching","title":"4.3 Waterfall Configuration &amp; Switching","text":"<ul> <li>Test Case 4.3.1: Verify waterfall model switching preserves class-specific logic</li> <li>Test Case 4.3.2: Verify configurable inter-class priority settings work correctly</li> <li>Test Case 4.3.3: Verify deterministic outputs match expected results for each class</li> <li>Test Case 4.3.4: Verify waterfall calculations can be validated against test vectors</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#5-workflow-automation","title":"5. Workflow Automation","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#51-class-specific-approval-workflows","title":"5.1 Class-Specific Approval Workflows","text":"<ul> <li>Test Case 5.1.1: Verify approval workflows for capital calls work per class</li> <li>Test Case 5.1.2: Verify distribution approval workflows respect class boundaries</li> <li>Test Case 5.1.3: Verify document approval workflows are class-segregated</li> <li>Test Case 5.1.4: Verify Class A and Class B workflows run concurrently without conflict</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#52-slas-reminders-escalations","title":"5.2 SLAs, Reminders &amp; Escalations","text":"<ul> <li>Test Case 5.2.1: Verify class-specific SLAs are enforced correctly</li> <li>Test Case 5.2.2: Verify reminder schedules work according to class configuration</li> <li>Test Case 5.2.3: Verify escalation procedures follow class-specific rules</li> <li>Test Case 5.2.4: Verify reminders are sent as configured for each class</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#53-ai-assisted-workflow-routing","title":"5.3 AI-Assisted Workflow Routing","text":"<ul> <li>Test Case 5.3.1: Verify AI-assisted routing reduces approval latency</li> <li>Test Case 5.3.2: Verify AI routing respects class-based permissions</li> <li>Test Case 5.3.3: Verify intelligent workflow optimization works across classes</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#6-basic-analytics","title":"6. Basic Analytics","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#61-class-level-capital-analytics","title":"6.1 Class-Level Capital Analytics","text":"<ul> <li>Test Case 6.1.1: Verify committed vs. deployed capital is tracked separately by class</li> <li>Test Case 6.1.2: Verify capital utilization reports are class-specific</li> <li>Test Case 6.1.3: Verify analytics data is only accessible to authorized class members</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#62-portfolio-analytics","title":"6.2 Portfolio Analytics","text":"<ul> <li>Test Case 6.2.1: Verify portfolio breakdown shows class-specific contributions</li> <li>Test Case 6.2.2: Verify class-specific return calculations are accurate</li> <li>Test Case 6.2.3: Verify consolidated portfolio views work for authorized users</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#63-reporting-export","title":"6.3 Reporting &amp; Export","text":"<ul> <li>Test Case 6.3.1: Verify reports are filterable by class</li> <li>Test Case 6.3.2: Verify PDF export functionality works for class-specific reports</li> <li>Test Case 6.3.3: Verify Excel export functionality works for class-specific data</li> <li>Test Case 6.3.4: Verify exported data maintains class-based security restrictions</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#7-ai-integration","title":"7. AI Integration","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#71-class-filtered-queries","title":"7.1 Class-Filtered Queries","text":"<ul> <li>Test Case 7.1.1: Verify AI queries respect class-based data access restrictions</li> <li>Test Case 7.1.2: Verify class-specific queries return accurate filtered results (e.g., \"Show returns for Class B LPs\")</li> <li>Test Case 7.1.3: Verify AI responses maintain class data segregation</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#72-ai-assisted-drafting","title":"7.2 AI-Assisted Drafting","text":"<ul> <li>Test Case 7.2.1: Verify AI-assisted capital call drafting uses correct class parameters</li> <li>Test Case 7.2.2: Verify AI-generated documents respect class-specific requirements</li> <li>Test Case 7.2.3: Verify AI drafts match class-specific formatting and content rules</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#73-ai-document-processing","title":"7.3 AI Document Processing","text":"<ul> <li>Test Case 7.3.1: Verify OCR + classification works with class awareness</li> <li>Test Case 7.3.2: Verify AI document processing respects class-based access controls</li> <li>Test Case 7.3.3: Verify automated classification assigns appropriate class tags</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#8-architecture-design","title":"8. Architecture Design","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#81-scalability-performance","title":"8.1 Scalability &amp; Performance","text":"<ul> <li>Test Case 8.1.1: Verify Corda node topology supports expected transaction volume</li> <li>Test Case 8.1.2: Verify API gateway handles concurrent multi-class requests</li> <li>Test Case 8.1.3: Verify system performance under multi-class load scenarios</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#82-integration-security-model","title":"8.2 Integration &amp; Security Model","text":"<ul> <li>Test Case 8.2.1: Verify API gateway integrations work with external services</li> <li>Test Case 8.2.2: Verify strict class-based segregation is maintained across all components</li> <li>Test Case 8.2.3: Verify audit capabilities work across the distributed architecture</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#9-fund-accounting","title":"9. Fund Accounting","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#91-multi-class-general-ledger","title":"9.1 Multi-Class General Ledger","text":"<ul> <li>Test Case 9.1.1: Verify general ledger maintains separate accounting for each class</li> <li>Test Case 9.1.2: Verify cross-class transactions are properly recorded</li> <li>Test Case 9.1.3: Verify accounting entries are auditable and traceable by class</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#92-nav-and-pl-calculations","title":"9.2 NAV and P&amp;L Calculations","text":"<ul> <li>Test Case 9.2.1: Verify NAV is calculated separately for each class</li> <li>Test Case 9.2.2: Verify combined NAV calculations are accurate</li> <li>Test Case 9.2.3: Verify P&amp;L calculations work correctly per class</li> <li>Test Case 9.2.4: Verify consolidated P&amp;L reports are accurate</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#10-portfolio-tracking","title":"10. Portfolio Tracking","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#101-class-based-investment-tracking","title":"10.1 Class-Based Investment Tracking","text":"<ul> <li>Test Case 10.1.1: Verify company profiles show investment history split by class</li> <li>Test Case 10.1.2: Verify class-specific contributions are tracked accurately</li> <li>Test Case 10.1.3: Verify class-based returns are calculated correctly</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#102-performance-metrics","title":"10.2 Performance Metrics","text":"<ul> <li>Test Case 10.2.1: Verify performance metrics are calculated separately per class</li> <li>Test Case 10.2.2: Verify consolidated portfolio views work for authorized users</li> <li>Test Case 10.2.3: Verify class-specific performance reports are accurate</li> <li>Test Case 10.2.4: Verify portfolio tracking data respects class-based access controls</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#test-execution-notes","title":"Test Execution Notes","text":""},{"location":"qa/Phase1_Functional_Test_Cases/#prerequisites","title":"Prerequisites","text":"<ul> <li>Multi-class test fund setup with Class A and Class B LPs</li> <li>Test users configured for each role (Admin, GP, LP Class A, LP Class B, Auditor, AI Assistant)</li> <li>Sample documents and transactions for each class</li> <li>Test vectors for waterfall calculations</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#success-criteria","title":"Success Criteria","text":"<ul> <li>All functional areas maintain strict class-based segregation</li> <li>No cross-class data leakage in any scenario</li> <li>All automated processes respect class-specific configurations</li> <li>Performance meets specified requirements under multi-class load</li> <li>All audit trails and logging function correctly</li> </ul>"},{"location":"qa/Phase1_Functional_Test_Cases/#test-data-requirements","title":"Test Data Requirements","text":"<ul> <li>Multi-class fund structures</li> <li>Class-specific user permissions</li> <li>Sample capital calls for each class</li> <li>Test waterfall scenarios with expected outputs</li> <li>Sample documents with class-specific access requirements</li> </ul> <p>Last Updated: August 23, 2025 Version: 1.0 Related: Phase1_PRD.md</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/","title":"DealSphere Phase 1: PRD to Functional Test Case Mapping","text":"<p>This artifact ensures traceability from every Product Requirement in the Phase 1 PRD to a corresponding Functional Test Case. For each PRD section, find links to mapped test cases\u2014and vice versa.</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#mapping-table","title":"Mapping Table","text":"PRD Feature/Requirement (Section) Mapped Functional Test Case(s) Platform &amp; Security Platform &amp; Security Document Management Document Management Capital Calls Capital Calls Waterfall Calculations Waterfall Calculations (Multi-Class) Workflow Automation Workflow Automation (Per Class) Basic Analytics Basic Analytics AI Integration AI Integration (Initial) Architecture Design Architecture Design Fund Accounting Fund Accounting Portfolio Tracking Portfolio Tracking"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#detailed-bidirectional-mapping","title":"Detailed Bidirectional Mapping","text":""},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#platform-security","title":"Platform &amp; Security","text":"<p>Covers: R3 Corda access, encryption, API enforcement, dynamic access rights \u2192 Platform &amp; Security Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#document-management","title":"Document Management","text":"<p>Covers: Metadata, off-ledger storage, versioning, hash checking, searchable OCR \u2192 Document Management Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#capital-calls","title":"Capital Calls","text":"<p>Covers: Notice generation, LP/class-specific logic, payment tracking, reminders/escalations \u2192 Capital Calls Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#waterfall-calculations-multi-class","title":"Waterfall Calculations (Multi-Class)","text":"<p>Covers: European/American models, class priorities, deterministic tests \u2192 Waterfall Calculations Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#workflow-automation-per-class","title":"Workflow Automation (Per Class)","text":"<p>Covers: Approvals, escalations, SLAs, AI latency reduction \u2192 Workflow Automation Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#basic-analytics","title":"Basic Analytics","text":"<p>Covers: Reports, export, capital/contribution breakdowns \u2192 Basic Analytics Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#ai-integration-initial","title":"AI Integration (Initial)","text":"<p>Covers: Querying, document classification, capital call assistance \u2192 AI Integration Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#architecture-design","title":"Architecture Design","text":"<p>Covers: Node deployment, API security, class segregation \u2192 Architecture Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#fund-accounting","title":"Fund Accounting","text":"<p>Covers: Ledger, NAV/P&amp;L per class \u2192 Fund Accounting Tests</p>"},{"location":"qa/Phase1_PRD_to_TestCase_Mapping/#portfolio-tracking","title":"Portfolio Tracking","text":"<p>Covers: Company profiles, investment returns by class, performance \u2192 Portfolio Tracking Tests</p>"},{"location":"tech/tech-landscape/","title":"Minimal Tech Landscape for DealSphere MVP","text":""},{"location":"tech/tech-landscape/#1-architectural-pattern","title":"1. Architectural Pattern","text":"<p>Monolithic Application</p> <ul> <li>Fast to develop and deploy for small teams and frequent iteration.</li> <li>Simplifies testing, transactions, and deployments.</li> <li>Ideal when domain boundaries are not fully volatile or discovered.</li> <li>All core modules (UI, business logic, data handling, integrations) live in a single deployable app.</li> <li>Use layered separation (Controller/Service/Repository) for maintainability and future migration to microservices, if needed.</li> </ul>"},{"location":"tech/tech-landscape/#2-core-tech-stack-choices","title":"2. Core Tech Stack Choices","text":"Layer Minimal Option (Best-fit) Web Frontend React (with Vite/CRA for speed, optional MUI/AntD for quick UI) Backend API/Logic Spring Boot (Java) or Node.js (Express) Database PostgreSQL (transactional &amp; mature; easy migration) File/Blob Storage S3-compatible service (e.g., AWS S3, MinIO local for MVP/dev) AuthN &amp; AuthZ JWT-based auth with Spring Security/Express middleware Document Management Local doc store + hash tracking in DB; integrate with S3 for scale AI Integration API-based calls to OpenAI/Claude (proxy for future custom models) R3 Corda As separate service; interface via HTTP/REST with mock for MVP Infra/CI Docker Compose (for local, simple), GitHub Actions for builds/tests"},{"location":"tech/tech-landscape/#3-optionalpluggable","title":"3. Optional/Pluggable","text":"<ul> <li>Admin UI built into main React app with feature flags.</li> <li>Basic monitoring: logs + health check endpoint.</li> <li>Email: SMTP or 3rd-party service (SendGrid/Mailgun) from backend.</li> </ul>"},{"location":"tech/tech-landscape/#4-fit-with-adrs","title":"4. Fit with ADRs","text":"<ul> <li>Stack above is aligned with accepted ADRs:<ul> <li>Layered separation (ADR: Modular boundaries)</li> <li>S3 or compatible (ADR: Object store)</li> <li>AI as external/sidecar (ADR: Cloud LLM API call)</li> <li>RBAC as API middleware (ADR: Simple Auth Middleware)</li> <li>Corda as remote or integrated API (ADR: Corda data plane)</li> <li>Single DB, pluggable storage (ADR: DB/storage split)</li> </ul> </li> </ul>"},{"location":"tech/tech-landscape/#5-migration-path","title":"5. Migration Path","text":"<ul> <li>Partition logic/services internally for easy \u201clift-and-split\u201d to microservices as needed.</li> <li>Wrap integrations/external calls in adapters/interfaces.</li> </ul>"},{"location":"tech/tech-landscape/#6-monolithic-viability","title":"6. Monolithic Viability","text":"<ul> <li>Monolithic application is strongly recommended for MVP:<ul> <li>PRD scope fits: user management, documents, workflows, analytics, integrations.</li> <li>Evolve to microservices if required for scale/organization.</li> </ul> </li> </ul>"},{"location":"tech/tech-landscape/#7-tech-landscape-diagram-text","title":"7. Tech Landscape Diagram (Text)","text":"<p>[React Frontend]          |   [Rest API (SpringBoot/Node)]          |    </p> <p>|     |     |      |    |    |   DB  S3/Blob Email  AI  Corda           (Postgres) (S3)   (SMTP) (API)</p>"}]}